---
title: 每天学点C++ (2)
date: 2024-03-19 08:27:13
categories: [Learning, 每天学点C++]
tags: [C++]
---

## 设计模式 (1)

什么是设计模式? What is DesignPatterns?

"每一个模式描述了一个在我们周围不断重复发生的问题，以及该问题的解决方案的核心。这样，你就能一次又一次地使用该方案而不必做重复劳动"

底层思维和抽象思维：设计模式解决的是抽象思维，两种思维需要并重。

软件设计复杂的根本原因：变化

如何解决复杂性：分解和抽象

软件设计的金科玉律: 复用

### 面向对象设计原则

1. 依赖倒置原则(DIP):
   高层模块不应该依赖于低层模块，它们应该依赖于抽象。
   抽象不应依赖于实现细节，实现细节应该依赖于抽象。
   举例：MainForm 不应该依赖于 Line 和 Rectangle，而是依赖于 Shape 这个抽象类，Line 实现 Draw 方法依赖于 Shape，而 Shape 不依赖于 Line

2. 开闭原则(OCP):
   对扩展开放，对修改封闭。
   类模块应该是可拓展，而是不可修改。
   举例：有新需求时应该添加新的类，而不是修改已有的类。

3. 单一职责原则(SRP):
   一个类应该仅有一个引起它变化的原因。
   变化的方向隐含着类的责任。

4. Liskov 原则(LSP):
   子类必须实现父类的方法。
   继承表达类型抽象。

5. 接口隔离原则(ISP):
   接口应该小而完备
   不应该强迫客户端依赖它们不使用的接口。

6. 优先使用组合而不是继承：
   组合是面向对象的扩展，继承是面向对象的重用。

7. 封装变化点：
   封装变化点，使得变化点在类间隔离，从而降低变化的影响。

8. 针对接口编程，而不是针对实现编程。
   可以降低类与类之间的耦合度，从而降低修改程序的难度。

接口标准化是产业强盛的标志！

学习设计模式的重点是理解设计模式在何时应该使用，而不是代码实现。

### Template Method

#### 动机

在软件构建过程中，对于某一项任务，它常常有稳定的整体操作结构，但各个子步骤却有很多改变的需求，或者由于固有的原因（比如框架与应用之间的关系）而无法和任务的整体结构同时实现。

如何在确定稳定操作结构的前提下，来灵活应对各个子步骤的变化或者晚期实现需求？

#### 结构化软件设计流程

![结构化软件设计流程](/images/每天学点C++/2.png)

#### 面向对象软件设计流程

![面向对象软件设计流程](/images/每天学点C++/3.png)

#### 早绑定与晚绑定

![早绑定与晚绑定](/images/每天学点C++/4.png)

#### 模式定义

定义一个操作中的算法的骨架 (稳定)在上面情况中是 Run 方法，而将一些步骤延迟(变化)到子类中。Template Method 使得子类可以不改变(复用)一个算法的结构即可重定义(override 重写)该算法的某些特定步骤。

#### 结构

![Template Method 结构](/images/每天学点C++/5.png)

### 策略模式 Strategy Pattern

#### 动机

在软件构建过程中，某些对象使用的算法可能多种多样，经常改变，如果将这些算法都编码到对象中，将会使对象变得异常复杂；
而且有时候支持不使用的算法也是一个性能负担。
如何在运行时根据需要透明地更改对象的算法？将算法与对象本身解耦，从而避免上述问题？

#### 模式定义

定义一系列算法，把它们一个个封装起来，并且使它们可互相替换（变化）。该模式使得算法可独立于使用它的客户程序(稳定)而变化（扩展，子类化）。

#### 结构

![策略模式结构](/images/每天学点C++/6.png)

#### 要点总结

- Strategy 及其子类为组件提供了一系列可重用的算法，从而可以使得类型在运行时方便地根据需要在各个算法之间进行切换。

- Strategy 模式提供了用条件判断语句以外的另一种选择，消除条件判断语句，就是在解耦合。含有许多条件判断语句的代码通常都需要 Strategy 模式。

- 如果 Strategy 对象没有实例变量，那么各个上下文可以共享同一个 Strategy 对象，从而节省对象开销。

### 观察者模式 Observer/Event

#### 动机

在软件构建过程中，我们需要为某些对象建立一种“通知依赖关系” ——一个对象（目标对象）的状态发生改变，所有的依赖对象（观察者对象）都将得到通知。如果这样的依赖关系过于紧密，将使软件不能很好地抵御变化。
使用面向对象技术，可以将这种依赖关系弱化，并形成一种稳定的依赖关系。从而实现软件体系结构的松耦合。

#### 模式定义

定义对象间的一种一对多（变化）的依赖关系，以便当一个对象(Subject)的状态发生改变时，所有依赖于它的对象都得到通知并自动更新。

#### 结构

![观察者模式 结构](/images/每天学点C++/7.png)

#### 要点总结

- 使用面向对象的抽象，Observer 模式使得我们可以独立地改变目标与观察者，从而使二者之间的依赖关系达致松耦合。
- 目标发送通知时，无需指定观察者，通知（可以携带通知信息作为参数）会自动传播。
- 观察者自己决定是否需要订阅通知，目标对象对此一无所知。
- Observer 模式是基于事件的 UI 框架中非常常用的设计模式，也是 MVC 模式的一个重要组成部分。
